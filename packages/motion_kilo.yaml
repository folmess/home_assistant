# =========================
# Package: sala_auto (codename: motion_kilo)
# Auto lights en Sala de Estar: escena, reducción/fade, restore desde snapshot, y waiting arrival
# timers por franja y "leaf lights"
#
# Requiere:
# - Integración HACS "var" (entidad: var.sala_snapshot_targets)
# - script.gradual_brightness_change  (externo)
# - script.gradual_restore_from_snapshot (externo)
# =========================

var:
  sala_snapshot_targets:
    initial_value: "{}"
    restore: true
    attributes:
      friendly_name: "SALA - Targets por-luz (JSON)"
      icon: mdi:code-json

# -------------------------
# HELPERS (estados / flags)
# -------------------------
input_select:
  sala_auto_state:
    name: SALA AUTO - Estado lógico
    options:
      - ACTIVE
      - IDLE_COUNTDOWN
      - PRE_NOTICE
      - RESTORE_WINDOW
      - WAITING_ARRIVAL
      - DISABLED
    initial: ACTIVE

input_boolean:
  sala_auto_bypass:
    name: SALA AUTO - Bypass general
    initial: off
  sala_auto_debug_mode:
    name: SALA AUTO - Debug
    initial: off
  sala_auto_fade:
    name: SALA AUTO - Usar fade en PRE_NOTICE
    icon: mdi:transition
    initial: on
  sala_auto_fading_active:
    name: SALA AUTO - Fading activo
    icon: mdi:animation-play-outline
    initial: off

# -------------------------
# HELPERS (tiempos y niveles)
# -------------------------
input_number:
  # Timeouts (min) por franja
  sala_auto_timeout_manana:
    name: Timeout - Mañana
    min: 1
    max: 60
    step: 1
    unit_of_measurement: minutes
    initial: 5
  sala_auto_timeout_mediodia:
    name: Timeout - Mediodía
    min: 1
    max: 60
    step: 1
    unit_of_measurement: minutes
    initial: 5
  sala_auto_timeout_tarde:
    name: Timeout - Tarde
    min: 1
    max: 60
    step: 1
    unit_of_measurement: minutes
    initial: 5
  sala_auto_timeout_noche:
    name: Timeout - Noche
    min: 1
    max: 60
    step: 1
    unit_of_measurement: minutes
    initial: 5
  sala_auto_timeout_madrugada:
    name: Timeout - Madrugada
    min: 1
    max: 60
    step: 1
    unit_of_measurement: minutes
    initial: 3

  # Arribo (ventana de restore, min) por franja
  sala_auto_arribo_manana:
    name: Arribo - Mañana
    min: 1
    max: 120
    step: 1
    unit_of_measurement: minutes
    initial: 4
  sala_auto_arribo_mediodia:
    name: Arribo - Mediodía
    min: 1
    max: 120
    step: 1
    unit_of_measurement: minutes
    initial: 4
  sala_auto_arribo_tarde:
    name: Arribo - Tarde
    min: 1
    max: 120
    step: 1
    unit_of_measurement: minutes
    initial: 4
  sala_auto_arribo_noche:
    name: Arribo - Noche
    min: 1
    max: 120
    step: 1
    unit_of_measurement: minutes
    initial: 4
  sala_auto_arribo_madrugada:
    name: Arribo - Madrugada
    min: 1
    max: 120
    step: 1
    unit_of_measurement: minutes
    initial: 2

  # Brillos por franja (fallback encendido simple)
  sala_auto_brightness_manana:
    name: Brightness - Mañana
    min: 0
    max: 255
    step: 1
    initial: 200
  sala_auto_brightness_mediodia:
    name: Brightness - Mediodía
    min: 0
    max: 255
    step: 1
    initial: 200
  sala_auto_brightness_tarde:
    name: Brightness - Tarde
    min: 0
    max: 255
    step: 1
    initial: 200
  sala_auto_brightness_noche:
    name: Brightness - Noche
    min: 0
    max: 255
    step: 1
    initial: 150
  sala_auto_brightness_madrugada:
    name: Brightness - Madrugada
    min: 0
    max: 255
    step: 1
    initial: 50

  # Reducción instantánea (cuando fade OFF)
  sala_auto_reduction_percentage:
    name: Reducción en PRE_NOTICE (%)
    min: 0
    max: 100
    step: 1
    unit_of_measurement: "%"
    initial: 50

  # Parámetros de fade
  sala_auto_fade_sec:
    name: Fade duración (s)
    min: 5
    max: 600
    step: 5
    unit_of_measurement: s
    initial: 30
  sala_auto_fade_reduce_pct:
    name: Fade - Reducir (% sobre % MIN actual)
    min: 0
    max: 100
    step: 5
    unit_of_measurement: "%"
    initial: 60

# -------------------------
# Efectos por franja (nombres de scripts)
# -------------------------
input_text:
  sala_auto_effect_script_name:
    name: Effect Script - Global
    initial: sala_arribo_global
  sala_auto_effect_script_manana:
    name: Effect Script - Mañana

  sala_auto_effect_script_mediodia:
    name: Effect Script - Mediodía

  sala_auto_effect_script_tarde:
    name: Effect Script - Tarde

  sala_auto_effect_script_noche:
    name: Effect Script - Noche

  sala_auto_effect_script_madrugada:
    name: Effect Script - Madrugada


# -------------------------
# TIMERS
# -------------------------
timer:
  sala_auto_idle_timeout:
    name: Idle countdown
    restore: true
  sala_auto_dim_notice:
    name: Pre-Notice
    restore: true
  sala_auto_restore_window:
    name: Restore Window
    restore: true

# -------------------------
# SCRIPTS
# -------------------------
script:

  # Guardar escena + volcar targets por-luz (JSON) en var.sala_snapshot_targets
  sala_auto_save_scene:
    alias: SALA AUTO - Guardar escena + targets JSON (leaf)
    mode: parallel
    sequence:
      - variables:
          leaf_lights: >
            {% set ns = namespace(leaf=[]) %}
            {% for l in area_entities('sala_de_estar') | select('match','light\\..*') %}
              {% set m = state_attr(l,'entity_id') %}
              {% set ns.leaf = ns.leaf + (m if m else [l]) %}
            {% endfor %}
            {{ ns.leaf | unique | list }}
          targets_map: >
            {% set ns = namespace(d={}) %}
            {% for e in expand(leaf_lights) %}
              {% set bri = state_attr(e.entity_id,'brightness') | int(0) %}
              {% set pct = (bri / 2.55) | round(0) | int %}
              {% set tgt = pct if e.state == 'on' else 0 %}
              {% set ns.d = ns.d | combine({ e.entity_id: tgt }) %}
            {% endfor %}
            {{ ns.d | to_json }}
      - service: scene.create
        data:
          scene_id: sala_auto_snapshot
          snapshot_entities: "{{ leaf_lights }}"
      # Guardar JSON largo en VAR (HACS) -> var.sala_snapshot_targets
      - service: var.set
        data:
          entity_id: var.sala_snapshot_targets
          value: "{{ targets_map }}"
          attributes:
            snapshot_taken_at: "{{ now().isoformat() }}"

  # Reducir brillo instantáneamente (cuando fade OFF)
  sala_auto_reduce_brightness:
    alias: SALA AUTO - Reducir brillo instantáneo (leaf)
    mode: parallel
    sequence:
      - variables:
          pd: "{{ states('sensor.parte_del_dia') }}"
          map_bri: >
            {{ {
              'manana':'input_number.sala_auto_brightness_manana',
              'mediodia':'input_number.sala_auto_brightness_mediodia',
              'tarde':'input_number.sala_auto_brightness_tarde',
              'noche':'input_number.sala_auto_brightness_noche',
              'madrugada':'input_number.sala_auto_brightness_madrugada'
            } }}
          base: "{{ states(map_bri[pd])|int if pd in map_bri else 200 }}"
          red: "{{ states('input_number.sala_auto_reduction_percentage')|int }}"
          target_bri: "{{ (base * (100 - red) / 100) | int }}"
          leaf_lights: >
            {% set ns = namespace(leaf=[]) %}
            {% for l in area_entities('sala_de_estar') | select('match','light\\..*') %}
              {% set m = state_attr(l,'entity_id') %}
              {% set ns.leaf = ns.leaf + (m if m else [l]) %}
            {% endfor %}
            {{ ns.leaf | unique | list }}
          on_lights: >
            {{ expand(leaf_lights) | selectattr('state','equalto','on') | map(attribute='entity_id') | list }}
      - choose:
          - conditions:
              - condition: template
                value_template: "{{ on_lights | length > 0 }}"
            sequence:
              - service: light.turn_on
                target: { entity_id: "{{ on_lights }}" }
                data: { brightness: "{{ target_bri }}", transition: 1 }

  # Apagar todas las luces del área (leaf)
  sala_auto_turn_off_lights:
    alias: SALA AUTO - Apagar luces (leaf)
    mode: parallel
    sequence:
      - variables:
          leaf_lights: >
            {% set ns = namespace(leaf=[]) %}
            {% for l in area_entities('sala_de_estar') | select('match','light\\..*') %}
              {% set m = state_attr(l,'entity_id') %}
              {% set ns.leaf = ns.leaf + (m if m else [l]) %}
            {% endfor %}
            {{ ns.leaf | unique | list }}
      - service: light.turn_off
        target: { entity_id: "{{ leaf_lights }}" }

  # Encendido (escena/efecto por franja o fallback simple)
  sala_auto_turn_on_lights:
    alias: SALA AUTO - Encender (escena/efecto por franja, leaf)
    mode: parallel
    sequence:
      - variables:
          use_scene_var: >
            {{ (use_scene | default(false)) | bool }}
          pd: "{{ states('sensor.parte_del_dia') }}"
          map_bri: >
            {{ {
              'manana':'input_number.sala_auto_brightness_manana',
              'mediodia':'input_number.sala_auto_brightness_mediodia',
              'tarde':'input_number.sala_auto_brightness_tarde',
              'noche':'input_number.sala_auto_brightness_noche',
              'madrugada':'input_number.sala_auto_brightness_madrugada'
            } }}
          map_fx: >
            {{ {
              'manana':'input_text.sala_auto_effect_script_manana',
              'mediodia':'input_text.sala_auto_effect_script_mediodia',
              'tarde':'input_text.sala_auto_effect_script_tarde',
              'noche':'input_text.sala_auto_effect_script_noche',
              'madrugada':'input_text.sala_auto_effect_script_madrugada'
            } }}
          brightness: "{{ states(map_bri[pd])|int if pd in map_bri else 200 }}"
          per_slot_fx: "{{ states(map_fx[pd]) if pd in map_fx else '' }}"
          global_fx: "{{ states('input_text.sala_auto_effect_script_name') }}"
          effect_name: >
            {% set pick = (per_slot_fx | trim) if (per_slot_fx | trim) != '' else (global_fx | trim) %}
            {{ pick }}
          effect_entity: >
            {{ ('script.' ~ effect_name) if (effect_name|length > 0) else '' }}
          leaf_lights: >
            {% set ns = namespace(leaf=[]) %}
            {% for l in area_entities('sala_de_estar') | select('match','light\\..*') %}
              {% set m = state_attr(l,'entity_id') %}
              {% set ns.leaf = ns.leaf + (m if m else [l]) %}
            {% endfor %}
            {{ ns.leaf | unique | list }}
      - choose:
          - conditions:
              - condition: template
                value_template: >
                  {{ use_scene_var and
                     (state_attr('scene.sala_auto_snapshot','entity_id') | default([]) | count > 0) }}
            sequence:
              - service: scene.turn_on
                target: { entity_id: scene.sala_auto_snapshot }
          - conditions:
              - condition: template
                value_template: >
                  {{ (not use_scene_var)
                     and (effect_entity|length > 0)
                     and (states(effect_entity) != 'unknown') }}
            sequence:
              - service: script.turn_on
                target: { entity_id: "{{ effect_entity }}" }
        default:
          - service: light.turn_on
            target: { entity_id: "{{ leaf_lights }}" }
            data: { brightness: "{{ brightness }}", transition: 1 }


  sala_auto_start_idle_flow:
    alias: SALA AUTO - Idle countdown flow
    mode: restart
    fields:
      timeout_seconds:
        name: Timeout override (seconds)
        description: Optional override for idle countdown duration in seconds.
        selector:
          number:
            min: 0
            max: 7200
            step: 1
            unit_of_measurement: "s"
    sequence:
      - variables:
          pd: "{{ states('sensor.parte_del_dia') }}"
          timeout_map: >
            {{ {
              'manana':'input_number.sala_auto_timeout_manana',
              'mediodia':'input_number.sala_auto_timeout_mediodia',
              'tarde':'input_number.sala_auto_timeout_tarde',
              'noche':'input_number.sala_auto_timeout_noche',
              'madrugada':'input_number.sala_auto_timeout_madrugada'
            } }}
          timeout_minutes_default: "{{ states(timeout_map[pd])|int if pd in timeout_map else 10 }}"
          timeout_override: "{{ timeout_seconds | default(none) }}"
          timeout_sec: >-
            {% set base = (timeout_minutes_default | int) * 60 %}
            {% set override = timeout_override %}
            {% if override is not none %}
              {{ [override | int, 0] | max }}
            {% else %}
              {{ [base, 0] | max }}
            {% endif %}
          pre_notice_sec: "{{ 120 if timeout_sec|int >= 120 else timeout_sec|int }}"
          wait_before_pre: "{{ max(timeout_sec|int - pre_notice_sec|int, 0) }}"
      - choose:
          - conditions:
              - condition: state
                entity_id: input_boolean.sala_auto_bypass
                state: "off"
              - condition: state
                entity_id: binary_sensor.motion_sala
                state: "off"
            sequence:
              - service: input_select.select_option
                target: { entity_id: input_select.sala_auto_state }
                data: { option: IDLE_COUNTDOWN }
              - service: timer.cancel
                target:
                  entity_id:
                    - timer.sala_auto_dim_notice
                    - timer.sala_auto_restore_window
              - service: input_boolean.turn_off
                target:
                  entity_id:
                    - input_boolean.sala_auto_fading_active
              - choose:
                  - conditions:
                      - condition: template
                        value_template: "{{ timeout_sec|int > 0 }}"
                    sequence:
                      - service: timer.start
                        target: { entity_id: timer.sala_auto_idle_timeout }
                        data: { duration: "{{ timeout_sec }}" }
                      - delay: "{{ wait_before_pre }}"
                      - condition: state
                        entity_id: binary_sensor.motion_sala
                        state: "off"
                      - condition: state
                        entity_id: input_boolean.sala_auto_bypass
                        state: "off"
                      - condition: state
                        entity_id: input_select.sala_auto_state
                        state: IDLE_COUNTDOWN
                      - condition: state
                        entity_id: timer.sala_auto_idle_timeout
                        state: "active"
                      - service: timer.start
                        target: { entity_id: timer.sala_auto_dim_notice }
                        data: { duration: "{{ pre_notice_sec }}" }
                      - service: timer.cancel
                        target: { entity_id: timer.sala_auto_idle_timeout }
        default: []

## ============================================
## Template sensor "dashboard-friendly"
## ============================================
template:
  - sensor:
      - name: "Sala Auto State"
        unique_id: sala_auto_state_sensor
        state: "{{ states('input_select.sala_auto_state') }}"
        attributes:
          # Mensaje "humano"
          next_action: >-
            {% set s = states('input_select.sala_auto_state') %}
            {% if s == 'DISABLED' %}
              Automático desactivado (bypass).
            {% elif s == 'ACTIVE' %}
              Movimiento en sala; luces gestionadas. Timers reiniciados.
            {% elif s == 'IDLE_COUNTDOWN' %}
              Sin movimiento: contando para preaviso.
            {% elif s == 'PRE_NOTICE' %}
              Preaviso: reduciendo brillo; pronto se apagarán.
            {% elif s == 'RESTORE_WINDOW' %}
              Ventana de restauración: esperando tu vuelta para restaurar la escena.
            {% elif s == 'WAITING_ARRIVAL' %}
              Esperando arribo: al volver, se encenderá según efecto/franja.
            {% else %}
              Estado desconocido.
            {% endif %}

          # Icono MDI sugerido para cada estado
          next_icon: >-
            {% set s = states('input_select.sala_auto_state') %}
            {% if s == 'DISABLED' %}mdi:cancel
            {% elif s == 'ACTIVE' %}mdi:run
            {% elif s == 'IDLE_COUNTDOWN' %}mdi:timer-sand
            {% elif s == 'PRE_NOTICE' %}mdi:brightness-4
            {% elif s == 'RESTORE_WINDOW' %}mdi:backup-restore
            {% elif s == 'WAITING_ARRIVAL' %}mdi:home-import-outline
            {% else %}mdi:help-circle
            {% endif %}

          # Color sugerido (para chips/cards que acepten icon_color)
          next_color: >-
            {% set s = states('input_select.sala_auto_state') %}
            {% if s == 'DISABLED' %}grey
            {% elif s == 'ACTIVE' %}green
            {% elif s == 'IDLE_COUNTDOWN' %}orange
            {% elif s == 'PRE_NOTICE' %}orange
            {% elif s == 'RESTORE_WINDOW' %}blue
            {% elif s == 'WAITING_ARRIVAL' %}teal
            {% else %}grey
            {% endif %}

          # Timer "vigente" según estado (útil para UI)
          timer_entity: >-
            {% set s = states('input_select.sala_auto_state') %}
            {% if s == 'IDLE_COUNTDOWN' %}timer.sala_auto_idle_timeout
            {% elif s == 'PRE_NOTICE' %}timer.sala_auto_dim_notice
            {% elif s == 'RESTORE_WINDOW' %}timer.sala_auto_restore_window
            {% else %}none
            {% endif %}

          # Remaining bruto (HH:MM:SS) del timer mapeado
          remaining: >-
            {% set t = this.attributes.timer_entity if this.attributes is defined else 'none' %}
            {% if t not in [none, 'none'] %}
              {{ state_attr(t, 'remaining') or '' }}
            {% else %}{% endif %}

          # Remaining lindo (mm:ss) si hay valor
          remaining_pretty: >-
            {% set raw = this.attributes.remaining if this.attributes is defined else '' %}
            {% if raw %}
              {% set p = strptime(raw, '%H:%M:%S') %}
              {{ '%02d:%02d' | format(p.hour*60 + p.minute, p.second) }}
            {% else %}{{ '' }}{% endif %}

# -------------------------
# AUTOMATIONS
# -------------------------
automation:

  # BYPASS ON → DISABLED
  - alias: sala_auto - Bypass ON → DISABLED
    id: sala_auto_bypass_on
    mode: single
    trigger:
      - platform: state
        entity_id: input_boolean.sala_auto_bypass
        to: "on"
    action:
      - service: input_select.select_option
        target: { entity_id: input_select.sala_auto_state }
        data: { option: DISABLED }
      - service: timer.cancel
        target:
          entity_id:
            - timer.sala_auto_idle_timeout
            - timer.sala_auto_dim_notice
            - timer.sala_auto_restore_window
      # No tocar luces
      # No tocar luces

  # BYPASS OFF → recompute por motion
  - alias: sala_auto - Bypass OFF → recompute
    id: sala_auto_bypass_off
    mode: single
    trigger:
      - platform: state
        entity_id: input_boolean.sala_auto_bypass
        to: "off"
    action:
      - choose:
          - conditions:
              - condition: state
                entity_id: binary_sensor.motion_sala
                state: "on"
            sequence:
              - service: input_select.select_option
                target: { entity_id: input_select.sala_auto_state }
                data: { option: ACTIVE }
          - conditions:
              - condition: state
                entity_id: binary_sensor.motion_sala
                state: "off"
            sequence:
              - service: script.turn_on
                target: { entity_id: script.sala_auto_start_idle_flow }


  # MOTION OFF -> IDLE_COUNTDOWN (inicia countdown, luego PRE_NOTICE si sigue off)
  - alias: sala_auto - Motion OFF -> IDLE_COUNTDOWN
    id: sala_auto_motion_off_idle
    mode: restart
    trigger:
      - platform: state
        entity_id: binary_sensor.motion_sala
        to: "off"
    condition:
      - condition: state
        entity_id: input_boolean.sala_auto_bypass
        state: "off"
    action:
      - service: script.turn_on
        target: { entity_id: script.sala_auto_start_idle_flow }
  # MOTION ON -> ACTIVE (V2): cancela fade si estaba, y si venías de PRE_NOTICE/RESTORE -> restore suave
  - alias: sala_auto - Motion ON -> ACTIVE (V2 restore suave)
    id: sala_auto_motion_on_active_v2
    mode: restart
    trigger:
      - platform: state
        entity_id: binary_sensor.motion_sala
        to: "on"
    condition:
      - condition: state
        entity_id: input_boolean.sala_auto_bypass
        state: "off"
    variables:
      prev_state: "{{ states('input_select.sala_auto_state') }}"
      fade_sec: "{{ states('input_number.sala_auto_fade_sec') | int(30) }}"
      steps: "{{ fade_sec }}"   # 1 paso/seg
      min_pct_floor: 10
    action:
      - service: input_select.select_option
        target: { entity_id: input_select.sala_auto_state }
        data: { option: ACTIVE }

      # Cancelar timers (ya no aplican al estar en ACTIVE)
      - service: timer.cancel
        target:
          entity_id:
            - timer.sala_auto_idle_timeout
            - timer.sala_auto_dim_notice
            - timer.sala_auto_restore_window

      # Si había fade corriendo, cancelarlo y bajar flag
      - choose:
          - conditions:
              - condition: state
                entity_id: input_boolean.sala_auto_fading_active
                state: "on"
            sequence:
              - service: script.turn_off
                target: { entity_id: script.gradual_brightness_change }
              - service: input_boolean.turn_off
                target: { entity_id: input_boolean.sala_auto_fading_active }

      # Restaurar según estado previo
      - choose:
          # Desde PRE_NOTICE o RESTORE_WINDOW -> restauración suave (usa VAR)
          - conditions:
              - condition: template
                value_template: "{{ prev_state in ['PRE_NOTICE','RESTORE_WINDOW'] }}"
            sequence:
              - service: script.turn_on
                target: { entity_id: script.gradual_restore_from_snapshot }
                data:
                  variables:
                    duration: "{{ fade_sec }}"
                    steps: "{{ steps }}"
                    min_pct: "{{ min_pct_floor }}"
          # Desde WAITING_ARRIVAL -> encendido por efecto/franja
          - conditions:
              - condition: template
                value_template: "{{ prev_state == 'WAITING_ARRIVAL' }}"
            sequence:
              - service: script.turn_on
                target: { entity_id: script.sala_auto_turn_on_lights }
                data:
                  variables: { use_scene: false }
        default: []

  # PRE_NOTICE START → set estado, snapshot + (fade o reducción instantánea)
  - alias: sala_auto - PRE_NOTICE START → snapshot + dim/fade + RESTORE WINDOW (parallel)
    id: sala_auto_pre_notice_start_parallel_restore
    mode: restart
    trigger:
      - platform: state
        entity_id: timer.sala_auto_dim_notice
        to: "active"
    variables:
      # Parámetros de fade/reducción
      reduce_pct: "{{ states('input_number.sala_auto_fade_reduce_pct') | int(60) }}"
      fade_sec: "{{ states('input_number.sala_auto_fade_sec') | int(30) }}"

      # Objetivo "seguro": % mínimo de las encendidas * (1 - reduce/100) → evita subidas
      leaf_lights: >
        {% set ns = namespace(leaf=[]) %}
        {% for l in area_entities('sala_de_estar') | select('match','light\\..*') %}
          {% set m = state_attr(l,'entity_id') %}
          {% set ns.leaf = ns.leaf + (m if m else [l]) %}
        {% endfor %}
        {{ ns.leaf | unique | list }}
      on_pcts: >
        {% set vals = [] %}
        {% for e in expand(leaf_lights) %}
          {% if e.state == 'on' %}
            {% set bri = state_attr(e.entity_id, 'brightness') | int(255) %}
            {% set pct = (bri / 2.55) | round(0) | int %}
            {% set vals = vals + [pct] %}
          {% endif %}
        {% endfor %}
        {{ vals }}
      min_pct_now: "{{ (on_pcts|min if (on_pcts|length > 0) else 100) | int }}"
      target_pct_global: >
        {{ ((min_pct_now * (100 - reduce_pct) / 100.0) | round(0) | int) }}

      # Duración de la ventana de restore por franja (ARRIBO)
      pd: "{{ states('sensor.parte_del_dia') }}"
      arribo_min: >
        {% set map = {
          'manana':'input_number.sala_auto_arribo_manana',
          'mediodia':'input_number.sala_auto_arribo_mediodia',
          'tarde':'input_number.sala_auto_arribo_tarde',
          'noche':'input_number.sala_auto_arribo_noche',
          'madrugada':'input_number.sala_auto_arribo_madrugada'
        } %}
        {{ states(map[pd])|int if pd in map else 15 }}
      restore_sec: "{{ (arribo_min | int) * 60 }}"
    action:
      # 1) Estado lógico a PRE_NOTICE
      - service: input_select.select_option
        target: { entity_id: input_select.sala_auto_state }
        data: { option: PRE_NOTICE }

      # 2) Guardar snapshot + targets (para restore suave)
      - service: script.turn_on
        target: { entity_id: script.sala_auto_save_scene }

      # 3) Iniciar (en paralelo) la ventana de RESTORE_WINDOW (solo timer + flag UI)
      - service: timer.cancel
        target: { entity_id: timer.sala_auto_restore_window }
      - choose:
          - conditions:
              - condition: template
                value_template: "{{ restore_sec | int > 0 }}"
            sequence:
              - service: timer.start
                target: { entity_id: timer.sala_auto_restore_window }
                data: { duration: "{{ restore_sec }}" }

      # 4) Ejecutar dim/fade del PRE_NOTICE
      - choose:
          - conditions:
              - condition: state
                entity_id: input_boolean.sala_auto_fade
                state: "on"
            sequence:
              - service: input_boolean.turn_on
                target: { entity_id: input_boolean.sala_auto_fading_active }
              # Llamada robusta al script externo (vía script.turn_on + variables)
              - service: script.turn_on
                target: { entity_id: script.gradual_brightness_change }
                data:
                  variables:
                    target:
                      area_id: sala_de_estar
                    target_brightness: "{{ [target_pct_global, 0] | max }}"
                    transition_time: "{{ fade_sec }}"
                    steps: "{{ fade_sec }}"
                    queue_mode: parallel
                    include_off_lights: false
                    flag_entity: input_boolean.sala_auto_fading_active
        default:
          - service: script.turn_on
            target: { entity_id: script.sala_auto_reduce_brightness }
  # PRE_NOTICE FIN → apagar + arrancar RESTORE_WINDOW (con Arribo por franja)
  - alias: sala_auto - PRE_NOTICE FIN → apagar + RESTORE START
    id: sala_auto_pre_notice_finish_off_restore
    mode: single
    trigger:
      - platform: event
        event_type: timer.finished
        event_data:
          entity_id: timer.sala_auto_dim_notice
    variables:
      pd: "{{ states('sensor.parte_del_dia') }}"
      arribo_min: >
        {% set map = {
          'manana':'input_number.sala_auto_arribo_manana',
          'mediodia':'input_number.sala_auto_arribo_mediodia',
          'tarde':'input_number.sala_auto_arribo_tarde',
          'noche':'input_number.sala_auto_arribo_noche',
          'madrugada':'input_number.sala_auto_arribo_madrugada'
        } %}
        {{ states(map[pd])|int if pd in map else 15 }}
    action:
      - service: input_boolean.turn_off
        target: { entity_id: input_boolean.sala_auto_fading_active }
      - service: script.turn_on
        target: { entity_id: script.sala_auto_turn_off_lights }

      - service: input_select.select_option
        target: { entity_id: input_select.sala_auto_state }
        data: { option: RESTORE_WINDOW }
      - service: timer.start
        target: { entity_id: timer.sala_auto_restore_window }
        data:
          duration: "{{ (arribo_min | int) * 60 }}"

  # RESTORE FIN → WAITING_ARRIVAL
  - alias: sala_auto - RESTORE FIN → WAITING_ARRIVAL
    id: sala_auto_restore_finish_waiting
    mode: single
    trigger:
      - platform: event
        event_type: timer.finished
        event_data:
          entity_id: timer.sala_auto_restore_window
    action:
      - service: input_select.select_option
        target: { entity_id: input_select.sala_auto_state }
        data: { option: WAITING_ARRIVAL }









