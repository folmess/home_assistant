# ===========================================
# Package: sala_auto (state machine driven, timers paralelos)
# ===========================================

#################################################################
# HELPERS
#################################################################
input_number:
  # --- Timeouts por franja (min) ---
  sala_auto_timeout_manana:
    name: Timeout - Mañana
    min: 1
    max: 60
    step: 1
    unit_of_measurement: minutes
    initial: 10
  sala_auto_timeout_mediodia:
    name: Timeout - Mediodía
    min: 1
    max: 60
    step: 1
    unit_of_measurement: minutes
    initial: 15
  sala_auto_timeout_tarde:
    name: Timeout - Tarde
    min: 1
    max: 60
    step: 1
    unit_of_measurement: minutes
    initial: 20
  sala_auto_timeout_noche:
    name: Timeout - Noche
    min: 1
    max: 60
    step: 1
    unit_of_measurement: minutes
    initial: 30
  sala_auto_timeout_madrugada:
    name: Timeout - Madrugada
    min: 1
    max: 60
    step: 1
    unit_of_measurement: minutes
    initial: 5

  # --- Brillo por franja (0..255) ---
  sala_auto_brightness_manana:
    name: Brightness - Mañana
    min: 0
    max: 255
    step: 1
    initial: 200
  sala_auto_brightness_mediodia:
    name: Brightness - Mediodía
    min: 0
    max: 255
    step: 1
    initial: 255
  sala_auto_brightness_tarde:
    name: Brightness - Tarde
    min: 0
    max: 255
    step: 1
    initial: 220
  sala_auto_brightness_noche:
    name: Brightness - Noche
    min: 0
    max: 255
    step: 1
    initial: 150
  sala_auto_brightness_madrugada:
    name: Brightness - Madrugada
    min: 0
    max: 255
    step: 1
    initial: 100

  # --- Porcentaje de reducción en PRE_NOTICE ---
  sala_auto_reduction_percentage:
    name: Reduction Percentage
    min: 0
    max: 100
    step: 1
    unit_of_measurement: "%"
    initial: 50

  # --- Ventana de ARRIBO (min) ---
  sala_auto_arribo_manana:
    name: Arribo - Mañana
    min: 1
    max: 120
    step: 1
    unit_of_measurement: minutes
    initial: 15
  sala_auto_arribo_mediodia:
    name: Arribo - Mediodía
    min: 1
    max: 120
    step: 1
    unit_of_measurement: minutes
    initial: 15
  sala_auto_arribo_tarde:
    name: Arribo - Tarde
    min: 1
    max: 120
    step: 1
    unit_of_measurement: minutes
    initial: 20
  sala_auto_arribo_noche:
    name: Arribo - Noche
    min: 1
    max: 120
    step: 1
    unit_of_measurement: minutes
    initial: 30
  sala_auto_arribo_madrugada:
    name: Arribo - Madrugada
    min: 1
    max: 120
    step: 1
    unit_of_measurement: minutes
    initial: 10

input_text:
  # --- Script global (fallback) ---
  sala_auto_effect_script_name:
    name: Effect Script - Global
    initial: sala_arribo_global
  # --- Script por franja (vacío => usa Global) ---
  sala_auto_effect_script_manana:
    name: Effect Script - Mañana
    initial: ""
  sala_auto_effect_script_mediodia:
    name: Effect Script - Mediodía
    initial: ""
  sala_auto_effect_script_tarde:
    name: Effect Script - Tarde
    initial: ""
  sala_auto_effect_script_noche:
    name: Effect Script - Noche
    initial: ""
  sala_auto_effect_script_madrugada:
    name: Effect Script - Madrugada
    initial: ""

input_boolean:
  sala_auto_debug_mode:
    name: Debug Mode
    initial: off
  sala_auto_dimmed:
    name: Luces reducidas (flag interno)
    initial: off
  sala_auto_restore_window_active:
    name: Ventana Arribo Activa
    initial: off
  sala_auto_bypass:
    name: Mantener luces sala (Bypass/Disabled)
    initial: off

# Estado controlado explícitamente
input_select:
  sala_auto_state:
    name: Sala · Auto State
    options:
      - DISABLED
      - ACTIVE
      - IDLE_COUNTDOWN
      - PRE_NOTICE
      - RESTORE_WINDOW
      - WAITING_ARRIVAL
    initial: WAITING_ARRIVAL

# Marca del fin de ventana total (pre_notice + arribo)
input_datetime:
  sala_auto_restore_end_at:
    name: Sala · Restore End At
    has_date: true
    has_time: true

#################################################################
# TIMERS (se renombran con prefijo sala_auto_)
#################################################################
timer:
  sala_auto_idle_timeout:
    name: Sala - Idle Timeout
    duration: "00:10:00"
    restore: true
  sala_auto_dim_notice:
    name: Sala - Dim Notice
    duration: "00:02:00"
    restore: true
  sala_auto_restore_window:
    name: Sala - Restore Window (PRE_NOTICE + ARRIBO)
    duration: "00:15:00"
    restore: true

#################################################################
# TEMPLATE (sensor espejo con atributos amigables)
#################################################################
template:
  - sensor:
      - name: "sala_auto_state"
        state: "{{ states('input_select.sala_auto_state') }}"
        icon: >-
          {% set s = states('input_select.sala_auto_state') %}
          {{ {
            'DISABLED':'mdi:power-off',
            'ACTIVE':'mdi:run-fast',
            'IDLE_COUNTDOWN':'mdi:timer-outline',
            'PRE_NOTICE':'mdi:bell-alert-outline',
            'RESTORE_WINDOW':'mdi:backup-restore',
            'WAITING_ARRIVAL':'mdi:motion-sensor-off'
          }.get(s, 'mdi:help-circle') }}
        attributes:
          next_action: >-
            {% set s = states('input_select.sala_auto_state') %}
            {{ {
              'DISABLED':'Bypass activo: no se enciende ni apaga automáticamente',
              'PRE_NOTICE':'Atenuado activo; apagado al terminar el preaviso',
              'IDLE_COUNTDOWN':'Sin movimiento; preaviso antes del apagado',
              'RESTORE_WINDOW':'Luces apagadas; se restaura la escena si vuelve el movimiento',
              'ACTIVE':'Luces activas por movimiento',
              'WAITING_ARRIVAL':'Esperando movimiento'
            }.get(s, 'Esperando movimiento') }}
          next_icon: >-
            {% set s = states('input_select.sala_auto_state') %}
            {{ {
              'DISABLED':'mdi:power-off',
              'PRE_NOTICE':'mdi:brightness-4',
              'IDLE_COUNTDOWN':'mdi:timer-outline',
              'RESTORE_WINDOW':'mdi:backup-restore',
              'ACTIVE':'mdi:run-fast',
              'WAITING_ARRIVAL':'mdi:motion-sensor-off'
            }.get(s, 'mdi:help-circle') }}
          next_color: >-
            {% set s = states('input_select.sala_auto_state') %}
            {{ {
              'DISABLED':'grey',
              'ACTIVE':'green',
              'IDLE_COUNTDOWN':'orange',
              'PRE_NOTICE':'orange',
              'RESTORE_WINDOW':'blue',
              'WAITING_ARRIVAL':'grey'
            }.get(s, 'grey') }}
          # ETA amigables (opcionales para dashboard)
          pre_notice_remaining_str: >-
            {% set r = state_attr('timer.sala_auto_dim_notice','remaining') %}
            {% if r %}
              {% set t = strptime(r, '%H:%M:%S') %}
              {{ '{:02d}:{:02d}'.format(t.hour*60 + t.minute, t.second) }}
            {% else %}--:--{% endif %}
          restore_end_at: "{{ states('input_datetime.sala_auto_restore_end_at') }}"
          restore_total_remaining_sec: >-
            {% set end = states('input_datetime.sala_auto_restore_end_at') %}
            {% if end %}
              {% set endt = as_datetime(end) %}
              {% set d = (endt - now()).total_seconds() | int %}
              {{ 0 if d < 0 else d }}
            {% else %}0{% endif %}

#################################################################
# SCRIPTS (leaf + efectos/escena) — todos con prefijo sala_auto_
#################################################################
script:
  sala_auto_save_scene:
    alias: SALA AUTO - Guardar escena snapshot (leaf)
    mode: parallel
    sequence:
      - variables:
          leaf_lights: >
            {% set ns = namespace(leaf=[]) %}
            {% for l in area_entities('sala_de_estar') | select('match','light\\..*') %}
              {% set m = state_attr(l,'entity_id') %}
              {% set ns.leaf = ns.leaf + (m if m else [l]) %}
            {% endfor %}
            {{ ns.leaf | unique | list }}
      - service: scene.create
        data:
          scene_id: sala_auto_snapshot
          snapshot_entities: "{{ leaf_lights }}"

  sala_auto_reduce_brightness:
    alias: SALA AUTO - Reducir brillo (solo encendidas, leaf)
    mode: parallel
    sequence:
      - variables:
          pd: "{{ states('sensor.parte_del_dia') }}"
          map_bri: >
            {{ {
              'manana':'input_number.sala_auto_brightness_manana',
              'mediodia':'input_number.sala_auto_brightness_mediodia',
              'tarde':'input_number.sala_auto_brightness_tarde',
              'noche':'input_number.sala_auto_brightness_noche',
              'madrugada':'input_number.sala_auto_brightness_madrugada'
            } }}
          base: "{{ states(map_bri[pd])|int if pd in map_bri else 200 }}"
          red: "{{ states('input_number.sala_auto_reduction_percentage')|int }}"
          target_bri: "{{ (base * (100 - red) / 100) | int }}"
          leaf_lights: >
            {% set ns = namespace(leaf=[]) %}
            {% for l in area_entities('sala_de_estar') | select('match','light\\..*') %}
              {% set m = state_attr(l,'entity_id') %}
              {% set ns.leaf = ns.leaf + (m if m else [l]) %}
            {% endfor %}
            {{ ns.leaf | unique | list }}
          on_lights: >
            {{ expand(leaf_lights) | selectattr('state','equalto','on') | map(attribute='entity_id') | list }}
      - choose:
          - conditions:
              - condition: template
                value_template: "{{ (on_lights | default([])) | length > 0 }}"
            sequence:
              - service: light.turn_on
                target: { entity_id: "{{ on_lights | default([]) }}" }
                data: { brightness: "{{ target_bri }}", transition: 1 }
      - service: input_boolean.turn_on
        target: { entity_id: input_boolean.sala_auto_dimmed }

  sala_auto_turn_off_lights:
    alias: SALA AUTO - Apagar luces (leaf)
    mode: parallel
    sequence:
      - variables:
          leaf_lights: >
            {% set ns = namespace(leaf=[]) %}
            {% for l in area_entities('sala_de_estar') | select('match','light\\..*') %}
              {% set m = state_attr(l,'entity_id') %}
              {% set ns.leaf = ns.leaf + (m if m else [l]) %}
            {% endfor %}
            {{ ns.leaf | unique | list }}
      - service: light.turn_off
        target: { entity_id: "{{ leaf_lights }}" }
      - service: input_boolean.turn_off
        target: { entity_id: input_boolean.sala_auto_dimmed }

  sala_auto_turn_on_lights:
    alias: SALA AUTO - Encender (scene/efecto por franja, leaf)
    mode: parallel
    sequence:
      - variables:
          use_scene_var: "{{ use_scene | default(false) | bool }}"
          pd: "{{ states('sensor.parte_del_dia') }}"
          map_bri: >
            {{ {
              'manana':'input_number.sala_auto_brightness_manana',
              'mediodia':'input_number.sala_auto_brightness_mediodia',
              'tarde':'input_number.sala_auto_brightness_tarde',
              'noche':'input_number.sala_auto_brightness_noche',
              'madrugada':'input_number.sala_auto_brightness_madrugada'
            } }}
          map_fx: >
            {{ {
              'manana':'input_text.sala_auto_effect_script_manana',
              'mediodia':'input_text.sala_auto_effect_script_mediodia',
              'tarde':'input_text.sala_auto_effect_script_tarde',
              'noche':'input_text.sala_auto_effect_script_noche',
              'madrugada':'input_text.sala_auto_effect_script_madrugada'
            } }}
          brightness: "{{ states(map_bri[pd])|int if pd in map_bri else 200 }}"
          per_slot_fx: "{{ states(map_fx[pd]) if pd in map_fx else '' }}"
          global_fx: "{{ states('input_text.sala_auto_effect_script_name') }}"
          effect_name: >
            {% set pick = (per_slot_fx | trim) if (per_slot_fx | trim) != '' else (global_fx | trim) %}
            {{ pick }}
          effect_entity: >
            {{ ('script.' ~ effect_name) if (effect_name|default('')|length > 0) else '' }}
          leaf_lights: >
            {% set ns = namespace(leaf=[]) %}
            {% for l in area_entities('sala_de_estar') | select('match','light\\..*') %}
              {% set m = state_attr(l,'entity_id') %}
              {% set ns.leaf = ns.leaf + (m if m else [l]) %}
            {% endfor %}
            {{ ns.leaf | unique | list }}

      - choose:
          - conditions:
              - condition: template
                value_template: >
                  {{ use_scene_var and
                     ((state_attr('scene.sala_auto_snapshot','entity_id') | default([])) | length > 0) }}
            sequence:
              - service: scene.turn_on
                target: { entity_id: scene.sala_auto_snapshot }
              - service: input_boolean.turn_off
                target: { entity_id: input_boolean.sala_auto_dimmed }

          - conditions:
              - condition: template
                value_template: >
                  {{ (not use_scene_var) and (effect_entity|default('')|length > 0)
                     and (states(effect_entity) not in ['unknown','unavailable']) }}
            sequence:
              - service: script.turn_on
                target: { entity_id: "{{ effect_entity }}" }
              - service: input_boolean.turn_off
                target: { entity_id: input_boolean.sala_auto_dimmed }

        default:
          - service: light.turn_on
            target: { entity_id: "{{ leaf_lights }}" }
            data: { brightness: "{{ brightness }}", transition: 1 }
          - service: input_boolean.turn_off
            target: { entity_id: input_boolean.sala_auto_dimmed }

#################################################################
# AUTOMATIONS (transiciones explícitas + restore paralelo)
#################################################################
automation:

  # BYPASS ON → DISABLED
  - alias: sala_auto - Bypass ON → DISABLED
    id: sala_auto_bypass_on
    mode: single
    trigger:
      - platform: state
        entity_id: input_boolean.sala_auto_bypass
        to: "on"
    action:
      - service: input_select.select_option
        target: { entity_id: input_select.sala_auto_state }
        data: { option: DISABLED }
      - service: timer.cancel
        target:
          entity_id:
            - timer.sala_auto_idle_timeout
            - timer.sala_auto_dim_notice
            - timer.sala_auto_restore_window
      - service: input_boolean.turn_off
        target:
          entity_id:
            - input_boolean.sala_auto_restore_window_active
            - input_boolean.sala_auto_dimmed
      # No tocar luces

  # BYPASS OFF → recompute por motion
  - alias: sala_auto - Bypass OFF → recompute
    id: sala_auto_bypass_off
    mode: single
    trigger:
      - platform: state
        entity_id: input_boolean.sala_auto_bypass
        to: "off"
    action:
      - choose:
          - conditions:
              - condition: state
                entity_id: binary_sensor.motion_sala
                state: "on"
            sequence:
              - service: input_select.select_option
                target: { entity_id: input_select.sala_auto_state }
                data: { option: ACTIVE }
          - conditions:
              - condition: state
                entity_id: binary_sensor.motion_sala
                state: "off"
            sequence:
              - service: input_select.select_option
                target: { entity_id: input_select.sala_auto_state }
                data: { option: IDLE_COUNTDOWN }
              - variables:
                  pd: "{{ states('sensor.parte_del_dia') }}"
                  timeout_min: >
                    {% set map = {
                      'manana':'input_number.sala_auto_timeout_manana',
                      'mediodia':'input_number.sala_auto_timeout_mediodia',
                      'tarde':'input_number.sala_auto_timeout_tarde',
                      'noche':'input_number.sala_auto_timeout_noche',
                      'madrugada':'input_number.sala_auto_timeout_madrugada'
                    } %}
                    {{ states(map[pd])|int if pd in map else 10 }}
                  timeout: "{{ (timeout_min | int) * 60 }}"
              - service: timer.start
                target: { entity_id: timer.sala_auto_idle_timeout }
                data: { duration: "{{ timeout }}" }

# MOTION ON → ACTIVE  (revisada)
  - alias: sala_auto - Motion ON → ACTIVE
    id: sala_auto_motion_on_active
    mode: restart
    trigger:
      - platform: state
        entity_id: binary_sensor.motion_sala
        to: "on"
    condition:
      - condition: state
        entity_id: input_boolean.sala_auto_bypass
        state: "off"
    variables:
      prev_state: "{{ states('input_select.sala_auto_state') }}"
    action:
      - service: system_log.write
        data:
          message: >
            [sala_auto] Motion detectado → ACTIVE. Estado previo={{ prev_state }}.
          level: info

      # Estado lógico
      - service: input_select.select_option
        target: { entity_id: input_select.sala_auto_state }
        data: { option: ACTIVE }

      # Cancelar timers
      - service: timer.cancel
        target:
          entity_id:
            - timer.sala_auto_idle_timeout
            - timer.sala_auto_dim_notice
            - timer.sala_auto_restore_window

      # Limpiar flags
      - service: input_boolean.turn_off
        target:
          entity_id:
            - input_boolean.sala_auto_restore_window_active
            - input_boolean.sala_auto_dimmed

      # (Opcional) matar script gradual si existe
      - choose:
          - conditions:
              - condition: template
                value_template: "{{ states('script.sala_auto_gradual_lights') not in ['unknown','unavailable'] }}"
            sequence:
              - service: script.turn_off
                target: { entity_id: script.sala_auto_gradual_lights }

      # Decidir acción de luces según estado previo
      - choose:
          # 1) Veníamos de PRE_NOTICE o RESTORE_WINDOW → restaurar snapshot
          - conditions:
              - condition: template
                value_template: "{{ prev_state in ['PRE_NOTICE','RESTORE_WINDOW'] }}"
            sequence:
              - event: sala_auto_debug
                event_data:
                  title: "Motion → Restaurar escena"
                  message: "Restaurando snapshot previo."
              - service: scene.turn_on
                target: { entity_id: scene.sala_auto_snapshot }

          # 2) Veníamos de WAITING_ARRIVAL → encendido por efecto/franja
          - conditions:
              - condition: template
                value_template: "{{ prev_state == 'WAITING_ARRIVAL' }}"
            sequence:
              - event: sala_auto_debug
                event_data:
                  title: "Motion → Script de franja"
                  message: "Ejecutando efecto por franja."
              - service: script.turn_on
                target: { entity_id: script.sala_auto_turn_on_lights }
                data:
                  variables: { use_scene: false }

        # 3) Otros previos (IDLE_COUNTDOWN, ACTIVE, DISABLED, etc.) → no tocar luces
        default:
          - event: sala_auto_debug
            event_data:
              title: "Motion → Sin cambios en luces"
              message: "Previo={{ prev_state }}."

    # MOTION OFF → IDLE_COUNTDOWN (arranca idle y programa preaviso - mata script gradual si existiese - revisada)
  - alias: sala_auto - Motion OFF → IDLE_COUNTDOWN
    id: sala_auto_motion_off_idle
    mode: restart
    trigger:
      - platform: state
        entity_id: binary_sensor.motion_sala
        to: "off"
    condition:
      - condition: state
        entity_id: input_boolean.sala_auto_bypass
        state: "off"
    variables:
      pd: "{{ states('sensor.parte_del_dia') }}"
      timeout_min: >
        {% set map = {
          'manana':'input_number.sala_auto_timeout_manana',
          'mediodia':'input_number.sala_auto_timeout_mediodia',
          'tarde':'input_number.sala_auto_timeout_tarde',
          'noche':'input_number.sala_auto_timeout_noche',
          'madrugada':'input_number.sala_auto_timeout_madrugada'
        } %}
        {{ states(map[pd])|int if pd in map else 10 }}
      timeout: "{{ (timeout_min | int) * 60 }}"
      pre_notice: "{{ 120 if timeout|int >= 120 else timeout|int }}"
      wait_before_pre: "{{ max(timeout|int - pre_notice|int, 0) }}"
    action:
      - service: input_select.select_option
        target: { entity_id: input_select.sala_auto_state }
        data: { option: IDLE_COUNTDOWN }

      # Cancelar cualquier aviso/ventana previos (el restore se programará al iniciar PRE_NOTICE)
      - service: timer.cancel
        target:
          entity_id:
            - timer.sala_auto_dim_notice
            - timer.sala_auto_restore_window

      # Limpiar flags visuales
      - service: input_boolean.turn_off
        target:
          entity_id:
            - input_boolean.sala_auto_restore_window_active
            - input_boolean.sala_auto_dimmed

      # Arrancar idle (si corresponde), y luego programar el preaviso
      - choose:
          - conditions:
              - condition: template
                value_template: "{{ timeout|int > 0 }}"
            sequence:
              - service: timer.start
                target: { entity_id: timer.sala_auto_idle_timeout }
                data: { duration: "{{ timeout }}" }

              # Esperar hasta el momento de PRE_NOTICE, verificando que todo siga aplicando
              - delay: "{{ wait_before_pre }}"
              - condition: state
                entity_id: binary_sensor.motion_sala
                state: "off"
              - condition: state
                entity_id: input_boolean.sala_auto_bypass
                state: "off"
              - condition: state
                entity_id: input_select.sala_auto_state
                state: IDLE_COUNTDOWN
              - condition: state
                entity_id: timer.sala_auto_idle_timeout
                state: "active"

              # Iniciar PRE_NOTICE (el RESTORE paralelo arranca en la automation de START)
              - service: timer.start
                target: { entity_id: timer.sala_auto_dim_notice }
                data: { duration: "{{ pre_notice }}" }

              # Cancelar el idle (ya no se necesita)
              - service: timer.cancel
                target: { entity_id: timer.sala_auto_idle_timeout }
  # PRE_NOTICE START → set estado + snapshot + dim + (RESTORE paralelo = pre_notice + arribo)
  - alias: sala_auto - PRE_NOTICE START
    id: sala_auto_pre_notice_start
    mode: single
    trigger:
      - platform: event
        event_type: timer.started
        event_data:
          entity_id: timer.sala_auto_dim_notice
    condition:
      - condition: state
        entity_id: input_boolean.sala_auto_bypass
        state: "off"
    variables:
      pd: "{{ states('sensor.parte_del_dia') }}"
      arribo_min: >
        {% set map = {
          'manana':'input_number.sala_auto_arribo_manana',
          'mediodia':'input_number.sala_auto_arribo_mediodia',
          'tarde':'input_number.sala_auto_arribo_tarde',
          'noche':'input_number.sala_auto_arribo_noche',
          'madrugada':'input_number.sala_auto_arribo_madrugada'
        } %}
        {{ states(map[pd])|int if pd in map else 15 }}
      # Duración actual del PRE_NOTICE (por seguridad, vuelve a tomarla del timer)
      pre_notice_sec: >-
        {% set r = state_attr('timer.sala_auto_dim_notice','duration') %}
        {% if r %}{% set t = strptime(r, '%H:%M:%S') %}{{ t.hour*3600 + t.minute*60 + t.second }}{% else %}120{% endif %}
      restore_total: "{{ (pre_notice_sec | int) + (arribo_min | int) * 60 }}"
    action:
      - service: input_select.select_option
        target: { entity_id: input_select.sala_auto_state }
        data: { option: PRE_NOTICE }
      - service: script.turn_on
        target: { entity_id: script.sala_auto_save_scene }
      - service: script.turn_on
        target: { entity_id: script.sala_auto_reduce_brightness }
      - service: input_boolean.turn_on
        target: { entity_id: input_boolean.sala_auto_dimmed }
      # Arranca RESTORE paralelo (pre_notice + arribo)
      - service: timer.start
        target: { entity_id: timer.sala_auto_restore_window }
        data: { duration: "{{ restore_total }}" }
      - service: input_boolean.turn_on
        target: { entity_id: input_boolean.sala_auto_restore_window_active }
      # Guardar ETA de fin de ventana
      - service: input_datetime.set_datetime
        target: { entity_id: input_datetime.sala_auto_restore_end_at }
        data:
          datetime: "{{ (now() + timedelta(seconds=restore_total|int)).strftime('%Y-%m-%d %H:%M:%S') }}"

  # PRE_NOTICE FIN → apagar y pasar a RESTORE_WINDOW (timer ya venía corriendo)
  - alias: sala_auto - PRE_NOTICE FIN
    id: sala_auto_pre_notice_finish
    mode: single
    trigger:
      - platform: event
        event_type: timer.finished
        event_data:
          entity_id: timer.sala_auto_dim_notice
    condition:
      - condition: state
        entity_id: input_boolean.sala_auto_bypass
        state: "off"
    action:
      - service: script.turn_on
        target: { entity_id: script.sala_auto_turn_off_lights }
      - service: input_select.select_option
        target: { entity_id: input_select.sala_auto_state }
        data: { option: RESTORE_WINDOW }

  # RESTORE FIN → limpiar flag y WAITING_ARRIVAL
  - alias: sala_auto - RESTORE FIN
    id: sala_auto_restore_fin
    mode: single
    trigger:
      - platform: event
        event_type: timer.finished
        event_data:
          entity_id: timer.sala_auto_restore_window
    action:
      - service: input_boolean.turn_off
        target: { entity_id: input_boolean.sala_auto_restore_window_active }
      - service: input_select.select_option
        target: { entity_id: input_select.sala_auto_state }
        data: { option: WAITING_ARRIVAL }
