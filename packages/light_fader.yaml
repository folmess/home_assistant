# packages/lights_fader.yaml
script:
  lights_fader:
    alias: Lights Fader
    description: "Fade manual de luces por pasos (sin transition)."
    fields:
      duration:
        name: Duration (seconds)
        description: "Cuántos segundos durará el fade."
        required: true
        example: 4
        selector:
          number:
            min: 0.1
            max: 3600
            step: 0.1
            mode: slider
      steps:
        name: Steps
        description: "Cantidad de pasos de cambio de brillo."
        required: true
        example: 8
        selector:
          number:
            min: 1
            max: 200
            step: 1
            mode: slider
      target:
        name: Target brightness (%)
        description: "Brillo final deseado (0–100). Si es 0, se apaga al final."
        required: true
        example: 50
        selector:
          number:
            min: 0
            max: 100
            step: 1
            mode: slider
            unit_of_measurement: "%"
      lights:
        name: Luces / Áreas / Dispositivos
        description: "Seleccioná entidades, áreas o dispositivos del dominio light."
        required: true
        selector:
          target:
            entity:
              domain: light
            area: {}
            device: {}
    mode: restart
    sequence:
      # ---------- Variables de trabajo ----------
      - variables:
          target_pct: "{{ target | int }}"
          total_steps: "{{ steps | int }}"
          # Ensayamos una lista de entity_id desde el target (acepta entidades, áreas y dispositivos)
          _sel_entities: "{{ (lights.entity_id or []) }}"
          _sel_areas: "{{ (lights.area_id or []) }}"
          _sel_devices: "{{ (lights.device_id or []) }}"
          _from_areas: "{{ _sel_areas | map('area_entities') | list | sum(start=[]) }}"
          _from_devices: "{{ _sel_devices | map('device_entities') | list | sum(start=[]) }}"
          _all_raw: "{{ (_sel_entities + _from_areas + _from_devices) | unique | list }}"
          # Filtramos sólo luces disponibles
          entity_ids: >-
            {% set objs = expand(_all_raw) %}
            {{ objs
               | selectattr('domain','equalto','light')
               | selectattr('state','ne','unavailable')
               | map(attribute='entity_id')
               | list }}
          # Brillo inicial por entidad (en %)
          initial_map: >-
            {% set ns = namespace(m={}) %}
            {% for e in entity_ids %}
              {% set bri = (state_attr(e,'brightness') | int(0)) %}
              {% set pct = (bri * 100 / 255) | round(0) %}
              {% set ns.m = dict(ns.m, **{e: pct|int}) %}
            {% endfor %}
            {{ ns.m }}
          # Milisegundos de delay por paso (más robusto que segundos flotantes)
          step_ms: "{{ ((duration | float(0)) * 1000 / (steps | int)) | round(0) }}"
      # ---------- Caso especial: sin luces válidas ----------
      - condition: template
        value_template: "{{ entity_ids | length > 0 }}"
      # ---------- Lógica principal ----------
      - choose:
          # Target == 0 => hacemos steps-1 y al final apagamos
          - conditions:
              - condition: template
                value_template: "{{ target_pct == 0 }}"
            sequence:
              - choose:
                  - conditions:
                      - condition: template
                        value_template: "{{ total_steps > 1 }}"
                    sequence:
                      - repeat:
                          count: "{{ total_steps - 1 }}"
                          sequence:
                            - variables:
                                progress: "{{ repeat.index / (total_steps - 1) }}"
                            - repeat:
                                for_each: "{{ entity_ids }}"
                                sequence:
                                  - variables:
                                      start: "{{ (initial_map[repeat.item] | int) }}"
                                      # Bajamos hacia >0; evitamos mandar 0 para que no apague antes de tiempo
                                      next_pct: >-
                                        {% set value = start + ((0 - start) * progress) %}
                                        {{ [1, [100, value|round(0)]|min]|max }}
                                  - service: light.turn_on
                                    target:
                                      entity_id: "{{ repeat.item }}"
                                    data:
                                      brightness_pct: "{{ next_pct }}"
                            - delay:
                                milliseconds: "{{ step_ms | int }}"
              # Apagado al final
              - service: light.turn_off
                target: "{{ lights }}"
        default:
          # Target > 0 => iteramos los 'steps' completos hasta el valor final
          - repeat:
              count: "{{ total_steps }}"
              sequence:
                - variables:
                    progress: "{{ repeat.index / total_steps }}"
                - repeat:
                    for_each: "{{ entity_ids }}"
                    sequence:
                      - variables:
                          start: "{{ (initial_map[repeat.item] | int) }}"
                          delta: "{{ target_pct - start }}"
                          next_pct: >-
                            {% set value = start + (delta * progress) %}
                            {{ [0, [100, value|round(0)]|min]|max }}
                      - service: light.turn_on
                        target:
                          entity_id: "{{ repeat.item }}"
                        data:
                          brightness_pct: "{{ next_pct }}"
                - delay:
                    milliseconds: "{{ step_ms | int }}"