# ===============================
# PACK: Sala de estar - Luces por movimiento con preaviso y helpers
# ===============================

homeassistant:
  customize: {}

# ------- HELPERS -------
# Bypass
input_boolean:
  mantener_luces:
    name: Mantener luces
    icon: mdi:hand-back-right

input_number:
  # Tiempos de apagado por parte del día (en minutos)
  sala_off_manana:
    name: Sala - Apagado mañana (min)
    min: 1
    max: 40
    step: 1
    unit_of_measurement: min
    icon: mdi:white-balance-sunny

  sala_off_mediodia:
    name: Sala - Apagado mediodía (min)
    min: 1
    max: 40
    step: 1
    unit_of_measurement: min
    icon: mdi:white-balance-sunny

  sala_off_tarde:
    name: Sala - Apagado tarde (min)
    min: 1
    max: 40
    step: 1
    unit_of_measurement: min
    icon: mdi:weather-sunset

  sala_off_noche:
    name: Sala - Apagado noche (min)
    min: 1
    max: 40
    step: 1
    unit_of_measurement: min
    icon: mdi:weather-night

  sala_off_madrugada:
    name: Sala - Apagado madrugada (min)
    min: 1
    max: 30
    step: 1
    unit_of_measurement: min
    icon: mdi:weather-night

  # Preaviso (en minutos)
  sala_preaviso:
    name: Sala - Preaviso (min)
    min: 1
    max: 30
    step: 1
    unit_of_measurement: min
    icon: mdi:timer-sand

# Timer independiente para el preaviso (lo usás en Lovelace como condición)
timer:
  preaviso_sala:
    name: Preaviso - Sala de estar
    restore: true

# ------- AUTOMATIZACIÓN PRINCIPAL -------
automation:
  - id: luces_sala_movimiento
    alias: Luces - Sala de estar - por movimiento
    mode: restart

    # Dispara cuando DEJA de haber movimiento
    trigger:
      - platform: state
        entity_id: binary_sensor.motion_sala
        from: 'on'
        to: 'off'

    # Bypass total si está activo
    condition:
      - condition: state
        entity_id: input_boolean.mantener_luces
        state: 'off'

    variables:
      # Área y snapshot
      area_name: "sala de estar"
      snapshot_id: "snapshot_sala_de_estar"

      # Parte del día actual (por sensor global)
      parte_del_dia: "{{ states('sensor.parte_del_dia') | lower }}"
      parte_del_dia_norm: "{{ parte_del_dia | replace('á','a') | replace('é','e') | replace('í','i') | replace('ó','o') | replace('ú','u') }}"

      # Minutos de apagado segun parte del día (fallback: noche)
      apagado_min: >-
        {% set mapa = {
          'manana': states('input_number.sala_off_manana')|int,
          'mediodia': states('input_number.sala_off_mediodia')|int,
          'tarde': states('input_number.sala_off_tarde')|int,
          'noche': states('input_number.sala_off_noche')|int,
          'madrugada': states('input_number.sala_off_madrugada')|int
        } %}
        {{ mapa.get(parte_del_dia_norm, states('input_number.sala_off_noche')|int) }}

      # Timeout de apagado en formato HH:MM:SS
      apagado_timeout: >-
        {% set mm = apagado_min|int %}
        {{ '%02d:%02d:%02d'|format((mm // 60), (mm % 60), 0) }}

      # Preaviso (minutos) y duración en segundos
      preaviso_min: "{{ states('input_number.sala_preaviso')|int }}"
      preaviso_seconds: "{{ (states('input_number.sala_preaviso')|int * 60) }}"

      # Listas de luces del área (todas / solo encendidas)
      luces_area: >-
        {{ expand(area_entities(area_name))
           | selectattr('entity_id','search','^light\\.')
           | map(attribute='entity_id') | list }}
      luces_area_on: >-
        {{ expand(area_entities(area_name))
           | selectattr('entity_id','search','^light\\.')
           | selectattr('state','eq','on')
           | map(attribute='entity_id') | list }}

    action:
      # Espera "apagado_timeout", pero se interrumpe si vuelve a ON el movimiento
      - wait_for_trigger:
          - platform: state
            entity_id: binary_sensor.motion_sala
            to: 'on'
        timeout: "{{ apagado_timeout }}"
        continue_on_timeout: true

      # Si volvió el movimiento durante ese tiempo, salimos
      - choose:
          - conditions: "{{ wait.completed }}"
            sequence:
              - stop: "Movimiento durante ventana de {{ apagado_min }} min → no se apagan luces."
        default:
          # Re-chequeo de bypass por si lo activaste en el medio
          - condition: state
            entity_id: input_boolean.mantener_luces
            state: 'off'

          # Snapshot del estado actual de las luces del área
          - service: scene.create
            data:
              scene_id: "{{ snapshot_id }}"
              snapshot_entities: "{{ luces_area }}"

          # Atenuar al 50% solo las que estén encendidas
          - if:
              - condition: template
                value_template: "{{ luces_area_on | length > 0 }}"
            then:
              - service: light.turn_on
                target:
                  entity_id: "{{ luces_area_on }}"
                data:
                  brightness_pct: 50
                  transition: 2

          # Iniciar timer de preaviso con la duración seteada por helper
          - service: timer.start
            target:
              entity_id: timer.preaviso_sala
            data:
              duration: "{{ preaviso_seconds }}"

          # Esperar EITHER: movimiento vuelve a on, OR el timer de preaviso termina
          - wait_for_trigger:
              - platform: state
                entity_id: binary_sensor.motion_sala
                to: 'on'
              - platform: event
                event_type: timer.finished
                event_data:
                  entity_id: timer.preaviso_sala
            timeout: "{{ apagado_timeout }}"   # límite de seguridad
            continue_on_timeout: true

          - choose:
              # Caso 1: volvió el movimiento DURANTE el preaviso → restaurar snapshot
              - conditions: >
                  {{ wait.trigger and
                     (wait.trigger.platform == 'state' and wait.trigger.to_state and
                      wait.trigger.to_state.state == 'on') }}
                sequence:
                  - condition: state
                    entity_id: input_boolean.mantener_luces
                    state: 'off'
                  - service: timer.cancel
                    target:
                      entity_id: timer.preaviso_sala
                  - service: scene.turn_on
                    target:
                      entity_id: "scene.{{ snapshot_id }}"
                    data:
                      transition: 2
                  - stop: "Movimiento durante preaviso → snapshot restaurado."

            # Caso 2: no volvió el movimiento y terminó el timer → apagar todas
            default:
              - condition: state
                entity_id: input_boolean.mantener_luces
                state: 'off'
              - service: light.turn_off
                target:
                  entity_id: "{{ luces_area }}"
                data:
                  transition: 2